# Effective Java

## 创建和销毁对象

### 第1条 考虑用静态工厂方法替代构造器

静态工厂方法与构造器相比的优势有：

* 静态工厂方法有名称

* 不必在每次调用它们的时候都创建一个新的对象

* 它们可以返回原返回类型的任何子类型的对象

* 在创建参数化实例的时候，使得代码变得更加简洁

静态工厂方法的主要缺点：

* 类如果不含公有的或受保护的构造器，就不能被子类化

* 它们与其他静态方法实际上没有任何区别

### 第2条 遇到多个构造器参数时要考虑用构建器

构建器参见《Java设计模式》第二版

### 第3条 用私有构造器或者枚举类型强化Singleton属性

### 第4条 通过私有构造器强化不可实例化的能力

### 第5条 避免创建不必要的对象

### 第6条 消除过期的对象引用

目的是避免内存泄露

内存泄露常见来源：

* 过期引用

* 缓存

* 监听器和其他回调

### 第7条 避免使用终结方法

## 对所有对象都通用的方法

### 第8条 覆盖equals方法时请遵守通用约定

约定内容：

equals方法实现了等价关系。

* 自反性。对于任何非null的引用值x, x.equals(x)必须返回True。

* 对称性。对于任何非null的引用值x和y，当且仅当y.equals(x)返回true时，x.equals(y)必须返回为true。

* 传递性。对于任何非null的引用值x,y和z。如果x.equals(y)返回true，并且y.equals(z)也返回true，那么x.equals(z)也必须返回true。

* 一致性。对于任何非null的引用值x和y，只有equals的比较操作对象中所用的信息没有被修改，多次调用x.equals(y)就会一致地返回true，或者一致地返回false。

对于任何非null的引用值x，x.equals(null)必须返回false。

### 第9条 覆盖equals时总是要覆盖hashCode

### 第10条 始终要覆盖toString
